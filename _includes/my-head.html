{% comment %}
<!--
Using `preload` so that page rendering doesn't get blocked.
Fill in `href`. You may have to adjust `as` and `onload`/`rel`, depending on content.
-->
<link href="<path/to/content.css>" rel="preload" as="style" onload="this.rel='stylesheet'">

<!--
Fallback in case JavaScript isn't enabled.
Fill in `href`. You may have to adjust `rel`.
-->
<noscript><link href="<path/to/content.css>" rel="stylesheet"></noscript>
{% endcomment %}

<!-- toc affix -->
<script type="module">
    document.querySelector('hy-push-state').addEventListener('load', () => {
      let tocElement = document.getElementById("markdown-toc");
  
      if(tocElement){
        let affixedDiv = document.createElement("div");
        affixedDiv.style.position = "relative";
        affixedDiv.style.top = "-1rem";
        tocElement.parentNode.insertBefore(affixedDiv, tocElement);
  
        let headerList = document.getElementsByClassName("permalink");
        if(headerList){
          let prevElement;
          window.addEventListener("scroll", () => {
            let hurdleTop = affixedDiv.getBoundingClientRect().top;
            if(hurdleTop <= 0) tocElement.classList.add("affix");
            else tocElement.classList.remove("affix");
  
            for(let i=0;i<headerList.length;i++){
              if(headerList[i].getBoundingClientRect().top >= 0){
                prevElement?.style.removeProperty("font-weight");
                let tocId = "markdown-toc-" + headerList[i].parentNode.id;
                prevElement = document.getElementById(tocId);
                prevElement.style.fontWeight = "bold";;
  
                break;
              }
            }
          });
        }
      }
    });
  </script>
  
  <script type="module">
    let p;
    const promisify = f => x => new Promise(r => f(x).addEventListener('load', r));
    const loadJS = promisify(window.loadJS);
    document.querySelector('hy-push-state').addEventListener('load', () => {
      const io = new IntersectionObserver(async (entries) => {
        if (entries.some(x => x.isIntersecting)) {
          p = p || loadJS('https://gumroad.com/js/gumroad-embed.js');
          await p;
          if (!window.GumroadEmbed) {
            await new Promise(function check1(res) {
              if ('createGumroadEmbed' in window) res(window.createGumroadEmbed());
              else setTimeout(() => check1(res), 200);
            });
          }
          await new Promise(function check2(res) {
            if ('GumroadEmbed' in window) res(GumroadEmbed.reload());
            else setTimeout(() => check2(res), 200);
          });
        }
      }, { rootMargin: '1440px' });
      document.querySelectorAll('.gumroad-product-embed').forEach(el => io.observe(el));
    });
  </script>
  <script type="module">
    let p;
    const promisify = f => x => new Promise(r => f(x).addEventListener('load', r));
    const loadJS = promisify(window.loadJS);
    document.querySelector('hy-push-state').addEventListener('load', () => {
      const io = new IntersectionObserver(async (entries) => {
        if (entries.some(x => x.isIntersecting)) {
          p = p || loadJS('https://gumroad.com/js/gumroad.js');
          await p;
          if (!window.GumroadOverlay) {
            await new Promise(function check(res) {
              if ('createGumroadOverlay' in window) res(window.createGumroadOverlay());
              else setTimeout(() => check(res), 200);
            });
          }
        }
      }, { rootMargin: '300px' });
      document.querySelectorAll('.gumroad-button').forEach(el => io.observe(el));
    });
  </script>